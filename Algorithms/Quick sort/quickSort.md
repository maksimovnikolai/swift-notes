## Быстрая сортировка

* **Быстрая сортировка работает намного быстрее чем Сортировка выбором.**

### Принцип - **Разделяй и Властвуй**
* Решение задачи методом "разделяй и властвуй" состоит из двух шагов:
1. Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных.
2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.

**Пример**:
**Нужно проссумировать все числа и вернуть сумму**

1.  **При помощи цикла**
```swift
func sum (_ arr: [Int]) -> Int {
    var total = 0
    for x in arr {
        total += x
    }
    return total
}

print(sum([1, 2, 3, 4])) // => 10
```

2. **При помощи рекурсивной функции:**
 - определить базовый случай
 - каждый рекурсивный вызов должен приближать к пустому массиву. 

```swift
func sum(list : [Int]) -> Int {
    if list.count == 0 { // <-- базовый случай
        return 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    return list[0] + sum(list: tempArray) // <-- рекурсивный случай
}

print(sum(list: [1, 2, 3, 4])) // => 10
```

**СОВЕТ:**
_Когда вы пишите рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента._

3. **Подсчет элементов в списке при помощи рекурсивной функции:**

```swift
func count(list : [Int]) -> Int {
    if list.count == 0 { // <-- базовый случай
        return 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    return 1 + count(list: tempArray) // <-- рекурсивный случай
}

print(count(list: [1, 2, 3, 4])) // => 4
```

3. **Рекурсивная функция для поиска наибольшего числа в списке:**

```swift
func max(list : [Int]) -> Int {
    if list.count == 2 {
        return (list[0] > list[1]) ? list[0] : list[1]
    } else if list.count < 2 {
        return list.first ?? 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    let subMax = max(list: tempArray)
    return (list[0] > subMax) ? list[0] : subMax
}

print(max(list: [1, 5, 10, 25, 16, 1])) // => 25
```