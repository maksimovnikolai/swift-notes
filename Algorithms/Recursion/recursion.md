## Рекурсия

* **Рекурсией называется вызов функцией самой себя**


### Базовый случай и рекурсивный случай

* Так как рекурсивная функция вызывает сама себя, легко ошибиться и написать функцию так, что возникнет бесконечный цикл.

* При написании рекурсивной функции необходимо указать, в какой момент следует прервать рекрсию.
**Поэтому каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая**.

```swift
func countDown(i : Int) {
    print(i)
    // Базовый случай: если i <= 0 тогда работа закончена
    if i <= 0 { 
        print("Работа закончена")
        return
    } else {
        // Рекурсивный случай: в противном случае вызвать countDown(i: i-1)
        print("Вызов функции countDown(i: \(i)-1)")
        countDown(i: i-1) 
    }
}

countDown(i: 5)
// print:
// 5
// Вызов функции countDown(i: 5-1)
// 4
// Вызов функции countDown(i: 4-1)
// 3
// Вызов функции countDown(i: 3-1)
// 2
// Вызов функции countDown(i: 2-1)
// 1
// Вызов функции countDown(i: 1-1)
// 0
// Работа закончена
```

## Стек вызовов

* Во внутренней работе компьютера используется стек, называемый **стеком вызовов**

```swift
func greet2(name: String) {
    print("how are you, \(name) ?")
}

func bye() {
    print("ok bye!")
}

//  Эта функция приветсвует вас, после чего вызывает две другие функции (greet2() и bye())
func greet(name: String ) {
    print("hello, \(name)!")
    greet2(name: name)
    print("getting ready to say bye...")
    bye()
}

greet(name: "adit")

// hello, adit!
// how are you, adit ?
// getting ready to say bye...
// ok bye!
```
Сначала компьютер выделяет блок памяти для функции greet(name: String)
Затем эта память используется. Переменной name присваивается значение "adit"; оно должно быть сохранено в памяти
        
      GREET
    NAME: ADIT

Каждый раз, когда вызывается функция, компьютер сохраняет в памяти значения всех переменных для этого вызова. 
Далее выводится приветствие hello, adit!, после чего следует второй вызов greet2("adit"). 
И снова компьютер выделяет блок памяти для вызова функции.

      GREET 2   <- текущий вызов функции
    NAME: ADIT
      GREET
    NAME: ADIT
Компьютер объединяет эти блоки в стек. Второй блок создается над первым. 
Вводится сообщение how are you, adit? после чего возвращает управление из вызова функции. 
Когда это происходит, блок на вершине стека извлекается из него.

      GREET
    NAME: ADIT
Теперь верхний блок относится к функции greet; это означает, что вы вернулись к функции greet. 
При вызове функции greet2 функция greet еще не была завершена.

**Когда вызывается функция из другой функции, вызывающая функция приостонавлявается в частично завершенном состоянии. Все значения переменных этой функции остаются в памяти. Акогда выполнение функции greet2 будет завершено, вы вернетесь к функции greet и продолжите ее выполнение с того места, где оно прервалось**

## Стек вызовов с рекурсией

* **Рекурсивные функции тоже используют стек вызовов!**

Пример: 
Функция вычисления факториала
```swift
func fact(x: Int) -> Int {
    if x == 1 {
        return 1
    } else {
        return x*fact(x: x-1)
    }
}


print(fact(x: 5)) // => 120
```

Стек удобен, но у него есть своя цена: сохранение всей промежуточной информации может привести к значительным затратам памяти. Каждый вызов функции занимает не много памяти, но если стек станет слишком высоким, это будет означать, что ваш компьютер сохраняет информацию по очень многим вызовам. На этой стадии есть два варианта:
    - Переписать код с использованием цикла
    - Иногда можно воспользоваться так называемой _хвостовой рекурсией_ (поддерживатеся не во всех языках)